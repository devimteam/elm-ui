var _abadi199$elm_input_extra$MaskedInput_Pattern$changedString = function (change) {
	var _p0 = change;
	switch (_p0.ctor) {
		case 'NoChange':
			return _p0._0;
		case 'Added':
			return _p0._0;
		case 'Removed':
			return _p0._0;
		default:
			return _p0._1;
	}
};
var _abadi199$elm_input_extra$MaskedInput_Pattern$foldPairs = F2(
	function (adjustment, pairs) {
		var concat = F3(
			function (isLeft, s, str) {
				return isLeft ? A2(_elm_lang$core$Basics_ops['++'], str, s) : A2(_elm_lang$core$Basics_ops['++'], s, str);
			});
		var fold = F3(
			function (isLeft, pair, str) {
				var _p1 = pair;
				if (_p1._0.ctor === 'Just') {
					if (_p1._0._0.ctor === 'Other') {
						switch (_p1._1.ctor) {
							case 'Removed':
								return isLeft ? A2(_elm_lang$core$String$dropRight, 1, str) : A2(_elm_lang$core$String$dropLeft, 1, str);
							case 'Added':
								return str;
							case 'Changed':
								return str;
							default:
								return str;
						}
					} else {
						switch (_p1._1.ctor) {
							case 'Removed':
								return str;
							case 'Added':
								return A3(concat, isLeft, _p1._1._0, str);
							case 'Changed':
								return A3(concat, isLeft, _p1._1._1, str);
							default:
								return A3(concat, isLeft, _p1._1._0, str);
						}
					}
				} else {
					switch (_p1._1.ctor) {
						case 'Removed':
							return str;
						case 'Added':
							return A3(concat, isLeft, _p1._1._0, str);
						case 'Changed':
							return A3(concat, isLeft, _p1._1._1, str);
						default:
							return A3(concat, isLeft, _p1._1._0, str);
					}
				}
			});
		var right = A3(
			_elm_lang$core$List$foldr,
			fold(false),
			'',
			pairs);
		var left = A3(
			_elm_lang$core$List$foldl,
			fold(true),
			'',
			pairs);
		var _p2 = adjustment;
		if (_p2.ctor === 'Backspace') {
			return left;
		} else {
			return right;
		}
	});
var _abadi199$elm_input_extra$MaskedInput_Pattern$isAdd = function (change) {
	var _p3 = change;
	if (_p3.ctor === 'Added') {
		return true;
	} else {
		return false;
	}
};
var _abadi199$elm_input_extra$MaskedInput_Pattern$splitChanges = function (changes) {
	var splitString = F2(
		function (change, str) {
			return A2(
				_elm_lang$core$List$map,
				change,
				A2(
					_elm_lang$core$List$map,
					_elm_lang$core$String$fromChar,
					_elm_lang$core$String$toList(str)));
		});
	var split = function (change) {
		var _p4 = change;
		switch (_p4.ctor) {
			case 'NoChange':
				return A2(splitString, _abadi199$elm_input_extra$Diff$NoChange, _p4._0);
			case 'Added':
				return A2(splitString, _abadi199$elm_input_extra$Diff$Added, _p4._0);
			case 'Removed':
				return A2(splitString, _abadi199$elm_input_extra$Diff$Removed, _p4._0);
			default:
				return A2(
					splitString,
					_abadi199$elm_input_extra$Diff$Changed(''),
					_p4._1);
		}
	};
	return _elm_lang$core$List$concat(
		A2(_elm_lang$core$List$map, split, changes));
};
var _abadi199$elm_input_extra$MaskedInput_Pattern$changesPairWithToken = F3(
	function (tokens, previous, current) {
		var splittedChanges = _abadi199$elm_input_extra$MaskedInput_Pattern$splitChanges(
			A2(_abadi199$elm_input_extra$Diff$diffChars, previous, current));
		var totalChanges = _elm_lang$core$List$length(splittedChanges);
		var getToken = F2(
			function (index, change) {
				var _p5 = change;
				if (_p5.ctor === 'Added') {
					return _elm_lang$core$Maybe$Nothing;
				} else {
					var tokenIndex = (_elm_lang$core$Native_Utils.cmp(
						_elm_lang$core$List$length(tokens),
						_elm_lang$core$String$length(previous)) < 0) ? ((_elm_lang$core$List$length(tokens) - 1) - index) : ((_elm_lang$core$String$length(previous) - 1) - index);
					return A2(_elm_community$list_extra$List_Extra$getAt, tokenIndex, tokens);
				}
			});
		var toPair = F2(
			function (change, results) {
				var index = function (length) {
					return length;
				}(
					_elm_lang$core$List$length(
						A2(
							_elm_lang$core$List$filter,
							function (_p6) {
								var _p7 = _p6;
								return !_abadi199$elm_input_extra$MaskedInput_Pattern$isAdd(_p7._1);
							},
							results)));
				return {
					ctor: '::',
					_0: {
						ctor: '_Tuple2',
						_0: A2(getToken, index, change),
						_1: change
					},
					_1: results
				};
			});
		return A3(
			_elm_lang$core$List$foldr,
			toPair,
			{ctor: '[]'},
			splittedChanges);
	});
var _abadi199$elm_input_extra$MaskedInput_Pattern$adjust = F4(
	function (tokens, adjustment, previous, current) {
		return A2(
			_abadi199$elm_input_extra$MaskedInput_Pattern$foldPairs,
			adjustment,
			A3(_abadi199$elm_input_extra$MaskedInput_Pattern$changesPairWithToken, tokens, previous, current));
	});
var _abadi199$elm_input_extra$MaskedInput_Pattern$isValid = F2(
	function (value, tokens) {
		var scanIsValid = F2(
			function (unscannedCharacters, unscannedTokens) {
				scanIsValid:
				while (true) {
					var isCharacterEmpty = _elm_lang$core$List$isEmpty(unscannedCharacters);
					var isTokenEmpty = _elm_lang$core$List$isEmpty(unscannedCharacters);
					var tailCharacters = A2(
						_elm_lang$core$Maybe$withDefault,
						{ctor: '[]'},
						_elm_lang$core$List$tail(unscannedCharacters));
					var tailTokens = A2(
						_elm_lang$core$Maybe$withDefault,
						{ctor: '[]'},
						_elm_lang$core$List$tail(unscannedTokens));
					var currentCharacter = _elm_lang$core$List$head(unscannedCharacters);
					var currentToken = _elm_lang$core$List$head(unscannedTokens);
					if (isCharacterEmpty && isTokenEmpty) {
						return true;
					} else {
						if (isCharacterEmpty && (!isTokenEmpty)) {
							return true;
						} else {
							if ((!isCharacterEmpty) && isTokenEmpty) {
								return false;
							} else {
								var _p8 = currentToken;
								if (_p8.ctor === 'Just') {
									if (_p8._0.ctor === 'Input') {
										var _v8 = tailCharacters,
											_v9 = tailTokens;
										unscannedCharacters = _v8;
										unscannedTokens = _v9;
										continue scanIsValid;
									} else {
										return A2(
											_elm_lang$core$Maybe$withDefault,
											false,
											A2(
												_elm_lang$core$Maybe$map,
												function (isMatch) {
													return isMatch ? A2(scanIsValid, tailCharacters, tailTokens) : false;
												},
												A2(
													_elm_lang$core$Maybe$map,
													F2(
														function (x, y) {
															return _elm_lang$core$Native_Utils.eq(x, y);
														})(_p8._0._0),
													currentCharacter)));
									}
								} else {
									return false;
								}
							}
						}
					}
				}
			});
		return A2(
			scanIsValid,
			_elm_lang$core$String$toList(value),
			tokens);
	});
var _abadi199$elm_input_extra$MaskedInput_Pattern$scan = F3(
	function (tokens, input, value) {
		var parseToken = F2(
			function (token, inputChar) {
				var _p9 = token;
				if (_p9.ctor === 'Input') {
					return A3(
						_abadi199$elm_input_extra$MaskedInput_Pattern$scan,
						A2(
							_elm_lang$core$Maybe$withDefault,
							{ctor: '[]'},
							_elm_lang$core$List$tail(tokens)),
						A2(
							_elm_lang$core$Maybe$withDefault,
							{ctor: '[]'},
							_elm_lang$core$List$tail(input)),
						A2(
							_elm_lang$core$Basics_ops['++'],
							value,
							_elm_lang$core$String$fromChar(inputChar)));
				} else {
					return _elm_lang$core$Native_Utils.eq(_p9._0, inputChar) ? A3(
						_abadi199$elm_input_extra$MaskedInput_Pattern$scan,
						A2(
							_elm_lang$core$Maybe$withDefault,
							{ctor: '[]'},
							_elm_lang$core$List$tail(tokens)),
						A2(
							_elm_lang$core$Maybe$withDefault,
							{ctor: '[]'},
							_elm_lang$core$List$tail(input)),
						value) : _elm_lang$core$String$fromList(input);
				}
			});
		var maybeInputChar = _elm_lang$core$List$head(input);
		var maybeToken = _elm_lang$core$List$head(tokens);
		var _p10 = maybeToken;
		if (_p10.ctor === 'Nothing') {
			return value;
		} else {
			return A2(
				_elm_lang$core$Maybe$withDefault,
				value,
				A2(
					_elm_lang$core$Maybe$map,
					parseToken(_p10._0),
					maybeInputChar));
		}
	});
var _abadi199$elm_input_extra$MaskedInput_Pattern$extract = F2(
	function (tokens, formatted) {
		return A3(
			_abadi199$elm_input_extra$MaskedInput_Pattern$scan,
			tokens,
			_elm_lang$core$String$toList(formatted),
			'');
	});
var _abadi199$elm_input_extra$MaskedInput_Pattern$append = F3(
	function (tokens, input, formatted) {
		append:
		while (true) {
			var maybeToken = _elm_lang$core$List$head(tokens);
			var appendInput = A2(
				_elm_lang$core$Maybe$withDefault,
				formatted,
				A2(
					_elm_lang$core$Maybe$map,
					A2(
						_abadi199$elm_input_extra$MaskedInput_Pattern$append,
						A2(
							_elm_lang$core$Maybe$withDefault,
							{ctor: '[]'},
							_elm_lang$core$List$tail(tokens)),
						A2(
							_elm_lang$core$Maybe$withDefault,
							{ctor: '[]'},
							_elm_lang$core$List$tail(input))),
					A2(
						_elm_lang$core$Maybe$map,
						function ($char) {
							return A2(
								_elm_lang$core$Basics_ops['++'],
								formatted,
								_elm_lang$core$String$fromChar($char));
						},
						_elm_lang$core$List$head(input))));
			var _p11 = maybeToken;
			if (_p11.ctor === 'Nothing') {
				return formatted;
			} else {
				var _p12 = _p11._0;
				if (_p12.ctor === 'Input') {
					return appendInput;
				} else {
					var _v14 = A2(
						_elm_lang$core$Maybe$withDefault,
						{ctor: '[]'},
						_elm_lang$core$List$tail(tokens)),
						_v15 = input,
						_v16 = A2(
						_elm_lang$core$Basics_ops['++'],
						formatted,
						_elm_lang$core$String$fromChar(_p12._0));
					tokens = _v14;
					input = _v15;
					formatted = _v16;
					continue append;
				}
			}
		}
	});
var _abadi199$elm_input_extra$MaskedInput_Pattern$format = F2(
	function (tokens, input) {
		return _elm_lang$core$String$isEmpty(input) ? input : A3(
			_abadi199$elm_input_extra$MaskedInput_Pattern$append,
			tokens,
			_elm_lang$core$String$toList(input),
			'');
	});
var _abadi199$elm_input_extra$MaskedInput_Pattern$Other = function (a) {
	return {ctor: 'Other', _0: a};
};
var _abadi199$elm_input_extra$MaskedInput_Pattern$Input = {ctor: 'Input'};
var _abadi199$elm_input_extra$MaskedInput_Pattern$tokenize = F2(
	function (inputChar, pattern) {
		return _elm_lang$core$Native_Utils.eq(pattern, inputChar) ? _abadi199$elm_input_extra$MaskedInput_Pattern$Input : _abadi199$elm_input_extra$MaskedInput_Pattern$Other(pattern);
	});
var _abadi199$elm_input_extra$MaskedInput_Pattern$parse = F2(
	function (inputChar, pattern) {
		return A2(
			_elm_lang$core$List$map,
			_abadi199$elm_input_extra$MaskedInput_Pattern$tokenize(inputChar),
			_elm_lang$core$String$toList(pattern));
	});
var _abadi199$elm_input_extra$MaskedInput_Pattern$OtherUpdate = {ctor: 'OtherUpdate'};
var _abadi199$elm_input_extra$MaskedInput_Pattern$Delete = {ctor: 'Delete'};
var _abadi199$elm_input_extra$MaskedInput_Pattern$Backspace = {ctor: 'Backspace'};
